It has a very minor noticable point when we think that the most distance node is the correct but instead our ans lies 
in combination of the most distant and its respective patience time;

class Pair{
    int node;
    int dis;
    Pair(int n, int d){
        node = n;
        dis  = d;
    }
}
class Solution {
    public int networkBecomesIdle(int[][] edges, int[] patience) {
        List<List<Integer>> adj = new ArrayList<>();
        int n = patience.length;
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;

        for(int i=0; i<n; i++){
            adj.add(new ArrayList<>());
        }

        for(int i=0; i<edges.length; i++){
            int u = edges[i][0];
            int v = edges[i][1];

            adj.get(u).add(v);
            adj.get(v).add(u);
        }

        PriorityQueue<Pair> q = new PriorityQueue<>((a,b) -> Integer.compare(a.dis, b.dis));
        q.add(new Pair(0,0));

        while(!q.isEmpty()){

            int node = q.peek().node;
            int dis = q.poll().dis;

            for(int nbr : adj.get(node)){
                if(dis + 1 < dist[nbr]){
                    dist[nbr] = dis+1;
                    q.add(new Pair(nbr, dist[nbr]));
                }
            }
        }

        int maxDist = 0, id = -1;
        for(int i=1; i<n; i++){
            int roundTripTime = 2 * dist[i];

            if(patience[i] >= roundTripTime){
                maxDist = Math.max(maxDist, roundTripTime + 1);
            }
            else{
                int totalMessages = roundTripTime/patience[i];
                if(roundTripTime % patience[i] > 0){
                    totalMessages++;
                }

                maxDist = Math.max(maxDist, patience[i]*(totalMessages-1)+roundTripTime+1);
            }
        }

        return maxDist;
    }
}
