class Solution {
    public int maxPartitionFactor(int[][] points) {
        int n = points.length;
        if(n <= 2) return 0;

        int maxDist = 0;

        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                int dist = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);

                maxDist = Math.max(maxDist, dist);
            }
        }

        int left = 0, right = maxDist;
        int ans = 0;

        while(left <= right){
            int mid = (left + right)/2;

            if(isPossible(mid,points)){
                ans = mid;
                left = mid+1;
            }
            else{
                right = mid - 1;
            }
        }

        return ans;
    }
    private boolean isPossible(int minDist, int[][] points){
        int n = points.length;
        List<Integer>[] graph = new ArrayList[n];

        for(int i=0; i<n; i++){
            graph[i] = new ArrayList<>();
        }

        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                int dist = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                
                if(dist < minDist){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }

        int[] vis = new int[n];

        for(int i=0; i<n; i++){
            if(vis[i] == 0){
                if(!isBipartite(i,vis,1,graph)) return false;
            }
        }

        return true;
    }
    private boolean isBipartite(int node, int[] vis, int col, List<Integer>[] adj){
        vis[node] = col;

        for(int nbr : adj[node]){
            if(vis[nbr] == 0){
                if(!isBipartite(nbr,vis,-col,adj)){
                    return false;
                }
            }
            else if(vis[nbr] == vis[node]) return false;
        }

        return true;
    }
}
